name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: write
  packages: write

jobs:
  release:
    runs-on: ubuntu-latest
    # Only run on main branch
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for changelog generation
          # Use PAT to allow pushing to protected branch
          # Create a Fine-grained PAT with 'Contents: Read and write' permission
          # Add it as RELEASE_TOKEN secret in repo settings
          token: ${{ secrets.RELEASE_TOKEN }}

      - name: Check for skip-release marker
        id: check_skip
        run: |
          # Check only the commit SUBJECT LINE (not body) for skip marker
          # Using %s format to get just the first line
          SUBJECT=$(git log -1 --pretty=%s)
          if echo "$SUBJECT" | grep -q '\[skip-release\]'; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping release due to [skip-release] in commit subject: $SUBJECT"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Proceeding with release check for: $SUBJECT"
          fi

      - name: Set up Python
        if: steps.check_skip.outputs.skip != 'true'
        uses: actions/setup-python@v6
        with:
          python-version: '3.11'

      - name: Install dependencies
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          python -m pip install --upgrade pip
          pip install python-semantic-release build twine

      - name: Configure Git
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Python Semantic Release
        id: release
        if: steps.check_skip.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ secrets.RELEASE_TOKEN }}
        run: |
          # Run semantic-release to determine if a release is needed
          # This parses commit messages following Conventional Commits:
          # - feat: -> minor version bump
          # - fix: -> patch version bump
          # - BREAKING CHANGE: -> major version bump

          # Check what version would be released
          NEW_VERSION=$(semantic-release version --print 2>/dev/null || echo "")

          if [ -n "$NEW_VERSION" ]; then
            echo "New version detected: $NEW_VERSION"
            echo "new_release=true" >> $GITHUB_OUTPUT
            echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

            # Perform the release (bumps version, commits, tags, creates GH release)
            semantic-release version
            semantic-release publish
          else
            echo "No release needed based on commit messages"
            echo "new_release=false" >> $GITHUB_OUTPUT
          fi

      - name: Build package
        if: steps.release.outputs.new_release == 'true'
        run: |
          python -m build
          twine check dist/*

      - name: Publish to PyPI
        if: steps.release.outputs.new_release == 'true'
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        run: |
          twine upload dist/*

      - name: Release summary
        if: steps.release.outputs.new_release == 'true'
        run: |
          echo "## ðŸŽ‰ Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Released version: **${{ steps.release.outputs.new_version }}**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Published to:" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… GitHub Releases" >> $GITHUB_STEP_SUMMARY
          echo "- âœ… PyPI (uvx/pip installable)" >> $GITHUB_STEP_SUMMARY
          echo "- ðŸ³ Docker images (via separate workflow)" >> $GITHUB_STEP_SUMMARY
